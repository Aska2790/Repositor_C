/***************************************
 * ********Аннаев Арслан****************
 * ***ProblemSet4(Ш++) pset4/recover.c**
 * ** Востановление jpg файла **********
 * *************************************
 * ************************************/

/**************************************
 * *****Разбор задания ****************
****1. Открыть входящий файл с содержимым памяти
****2. Найти начало JPEG файла
****3. Создать новый исходящий файл
****4. Записываем в него блок памяти 
****5. Закрыть оба файла
***********************************/
 
 #include <stdio.h>     // стандартная библиотека ввода вывода
 #include <stdint.h>    // работа с типом данных uint8_t

//============================================================================================================================

#define BUFFER_SIZE 512             // размер буфера

#define H_FORM1 0xff                // формат первого байта файла jpg
#define H_FORM2 0xd8                // формат второго байта файла jpg
#define H_FORM3 0xff                // формат третьего байта файла jpg
#define H_FORM4 0xe0                // формат четвертого байта файла jpg или
#define H_FORM5 0xe1                // формат четвертого байта файла jpg

//============================================================================================================================

typedef uint8_t BYTE;               // использование имени BYTE

int checking (BYTE *buf);           // функция проверки заголовка файла
 
 //============================================================================================================================
 // точка входа с двумя аргументами
int main(int argc, char *argv[])
 {
     
    // если вызов программы не имеет 4 аргументов 
    if (argc != 2)
    {
        fprintf(stderr,"Usage: ./resize n infile outfile \n");  // инсрукция по вызову программы
        return 1;
    } 
    
    char *infile =  argv[1];                            // имя файла принятого из второго аргумента
    
    BYTE buffer[BUFFER_SIZE];                           // буфер для временного хранения куска памяти
    int counter = 0;                                    // счетчик для динамического именования файлов
    char filename[4];                                   // имя файла
    
    FILE *outptr = NULL;                                // указатель файла для исходящих значений
    FILE *inptr = fopen(infile, "r");                   // создаем обьект файла для считывания 
    if (inptr == NULL)    {                             // если указатель пустой
        fprintf(stderr,"Could not open.\n");            // сообщение пользователю
        return 2;
    }
    
    
    fseek(inptr, 0, SEEK_END);                          // переместить внутренний указатель в конец файла
    long len = ftell(inptr)/BUFFER_SIZE;                // получаем количество блоков состоящих из BUFFER_SIZE
    
    fseek(inptr, 0, SEEK_SET);                          // возвращаем указатель на начало файла
//============================================================================================================================    
    // цикл с количеством итерация равное количеству блоков в данной адресации памяти
    for(int i =0; i < len; i++){        
        fread(buffer, BUFFER_SIZE, 1, inptr);           // считываем блок размером 512 байт
        
        if(checking(buffer)==0) {                       // проверка соответствия формату
                sprintf(filename, "%03d.jpg", counter); // генерируем имя для нового блока (файла)
               
                outptr = fopen(filename, "w");          // открываем файл с именем которое сгенерировалось
               
                counter++;                              // увеличиваем счетчик для того что бы знать количество файлов 
            }
        
            if (outptr != NULL)                         // если указатель не пустой
            fwrite(buffer, BUFFER_SIZE, 1, outptr);     // записать блок памяти в файл
            
    }
//============================================================================================================================    
   
    fclose(outptr);                                     // закрыть исходящий файл
    fclose(inptr);                                      // закрыть исходящий файл
 
    return 0;
 } 
 
 //============================================================================================================================
 // функция проверки заголовка 
int checking (BYTE *buf)
 {
    if (buf[0] == H_FORM1  && buf[1] == H_FORM2  && 
        buf[2] == H_FORM3  && (buf[3] == H_FORM4 || buf[3] == H_FORM5)) 
            return 0;
    
    return 1;
 }
 
 //============================================================================================================================